# 基本数据结构
## 选择正确的数据结构 
根据需求，主要是  
1.增删改查 及其作用位置  
2.复制 反转等

**调用C++类时也要清楚他内置成员函数的时间复杂度**，例如list类的删除节点是O(1),而vector是O(n)  

--------
## City_Skyline
### 题目描述
你是一名没什么游戏经验的《都市天际线》玩家，因此你在修好一条长长的笔直的双车道公路之后直接在它的一侧规划了一整排高密度居民区。看着你的即将造成恐怖的拥堵的建筑成果，你不禁开始思考，站在这些高密度居民区楼顶的居民有多少人可以互相看到对方呢？我们不妨假设每栋楼房各有一个高度，如果两栋楼房之间不存在其他楼房或不存在高于两栋楼房当中较低者的楼房，则认为站在这两栋楼房顶部的居民可以互相看见。现在请计算存在多少对楼房使得站在这对楼房顶部的居民可以相互看见。

### 输入格式
本题有多组测试数据。第一行输入一个整数T
，表示数据组数。每组数据各有两行，第一行是一个正整数n
，表示楼房的数量；第二行是n
个整数，表示从左到右各个楼房的高度。
### 输出格式
每组数据输出一行一个整数，表示可以互相看到的楼房对数。
### Way1  O(n^2) 做法+剪枝
如源代码所示，我们不要考虑先列出来所有对下标再进行比较，这样肯定是n^3  

我们考虑在遍历的同时确定是否可能，只需要维护一个 highest 表示 i,j 之间的最高楼  

**关键剪枝**当 highest>left 时，跳出循环
### Way2
我们用一个单调栈来维护一个三元组tri，分别包含高度，同高度数量以及此群组向左看到的数量

**只需要计算所有群组向左看到的数量之和即为答案**  
这是一种 ***降维思想***，我们虽然在找对数，但也可以单个考虑元素，只考虑一个方向即可
```c++
struct tri{
    int high;
    int num;
    int subans;
};
int see(const vector<int>& build) {
    stack<tri> st;
    int ans=0;
    for(int high:build) {
        int cnt=0;//记录这个高度的楼(群)向左看一共能看到多少楼 也即subans  弹出时把cnt加入ans
        while(!st.empty()&&high>st.top().high) {
            ans+=st.top().subans;//可以看到这些比 high 矮的连续的楼，以及比栈顶高的楼 高度位于两栈之间的不可见
            cnt+=st.top().num;
            st.pop();
        }
        if(st.empty()) {
            st.push({high,1,cnt});
        }else if(high==st.top().high) {
            //看到等高的所有楼
            cnt+=st.top().num;
            //还能看见更高的一栋楼，但不知道存不存在
            if(st.size()>1)cnt++;
            st.top().num++;//合并
            st.top().subans+=cnt;
        }else {
            //high<st.top().first 只能看到最近的一栋
            cnt++;
            st.push({high,1,cnt});
        }
    }
    //把答案加起来
    while(!st.empty()){
        ans+=st.top().subans;
        st.pop();
    }
    return ans;
}
```
### Way2 plus
我们仔细理解单调栈以后，发现在每次操作时直接改变ans即可，无需subans延迟计数
```c++
int see(const vector<int>& build) {
  int ans=0;
    stack<pair<int,int>> st;
    for(int high:build) {
while(!st.empty()&&high>st.top().first) {
    ans+=st.top().second;
    st.pop();
}
    if(st.empty()) {
        st.push({high,1});
    }else if(high==st.top().first) {
        ans+=st.top().second;
        if(st.size()>1)ans++;
        st.top().second++;
    }else {
        //high<sec
        ans++;
        st.push({high,1});
    }

    }
return ans;
}
```





-------
## 其他细节
### 1.注意while循环条件的边界
```c++
 while(cmds.size()<k&&i<m) {
        //当size==k-1时最后一次进入循环！！！
        cmds.push_back(cmds[i]);
        i++;
    }
```
### 2.注意避免混用C风格和C++
```c++
//string 不以\0结尾，不能用C风格处理

 string sub=cmds[ptr].substr(3);//substr  截取string
 int m=stoi(sub);//stoi  string转数字
```
### 3.getline
用于读取一整行字符串，而不会被空白符打断
```c++
getline(cin,cmd);
```
但注意之前cin残留的换行符
```c++
//用ignore 抵消
cin.ignore(1, '\n');
```